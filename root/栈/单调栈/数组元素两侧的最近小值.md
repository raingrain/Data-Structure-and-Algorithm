# [数组元素两侧的最近小值]()

### 题意

![image](https://user-images.githubusercontent.com/75558694/178128522-8b049d1b-2cf1-411a-9f94-76bb4c3e2c74.png)

---

### Java实现

#### *思路*

> **- 暴力循环法**
>   - 暴力方法就是遍历数组中每个元素的左右两侧，找到小值就停止遍历并记录最近小值的索引，时间复杂度为O(N^2)
>
> ---
>
> **- 单调栈法**
>   1. 首先我们的双端队列需要自己处理窗口长度，我们采用检查过期元素的方式省去了对left的限制，只专注于right
>   2. 由于题目中窗口长度固定为k，不同于暴力方法中最开始的窗口是从0到k-1，我们通过判断什么时候往res中填答案来解决最开始队列不完整的问题（双端队列法从没有值开始扩张窗口），即只有当 `right >= k - 1` 时才开始往res中填答案

#### *代码*

```java
public class Solution {

    // 暴力循环法
    public static int[][] getNearLessByViolenceLoop(int[] arr) {
        int[][] res = new int[arr.length][2];
        for (int i = 0; i < arr.length; i++) {
            int leftNearLessIndex = -1;
            int rightNearLessIndex = -1;
            int cur = i - 1;
            while (cur >= 0) {
                if (arr[cur] < arr[i]) {
                    leftNearLessIndex = cur;
                    break;
                } else {
                    cur--;
                }
            }
            cur = i + 1;
            while (cur < arr.length) {
                if (arr[cur] < arr[i]) {
                    rightNearLessIndex = cur;
                    break;
                } else {
                    cur++;
                }
            }
            res[i][0] = leftNearLessIndex;
            res[i][1] = rightNearLessIndex;
        }
        return res;
    }

    // 单调栈法（限定于无重复值）
    public static int[][] getNearLessNoRepeatByMonotonicStack(int[] arr) {
        int[][] res = new int[arr.length][2];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < arr.length; i++) {
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
                int peek = stack.pop();
                res[peek][0] = stack.isEmpty() ? -1 : stack.peek();
                res[peek][1] = i;
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int peek = stack.pop();
            res[peek][0] = stack.isEmpty() ? -1 : stack.peek();
            res[peek][1] = -1;
        }
        return res;
    }

    // 单调栈法（满足所用情况）
    public static int[][] getNearLessByMonotonicStack(int[] arr) {
        int[][] res = new int[arr.length][2];
        // 栈中以链表作为元素，链表内按照遍历顺序存储值相同的索引
        Stack<ArrayList<Integer>> stack = new Stack<>();
        // 遍历每一个索引并入栈
        for (int i = 0; i < arr.length; i++) {
            // 如果栈不为空且当前索引对应值小于栈顶索引对应值，对栈顶链表内元素执行结算操作
            while (!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]) {
                // 获取链表
                ArrayList<Integer> peeks = stack.pop();
                // 如果栈为空了，你左边没有比你小的，不为空就是当前栈顶链表的最后一个元素
                int leftNearLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
                // 链表内所有索引的结果相同
                for (Integer peek : peeks) {
                    res[peek][0] = leftNearLessIndex;
                    res[peek][1] = i;
                }
            }
            // 如果当前索引对应值等于栈顶索引对应值，直接就加到栈顶链表
            if (!stack.isEmpty() && arr[stack.peek().get(0)] == arr[i]) {
                stack.peek().add(i);
            } else {
                // 如果当前栈为空或者当前索引对应值大于栈顶索引对应值，直接建一个新链表入栈
                ArrayList<Integer> list = new ArrayList<>();
                list.add(i);
                stack.push(list);
            }
        }
        // 有可能所有索引都遍历一遍后栈中还剩下元素
        // 进行结算
        // 显然其右边必定没有元素比它小
        while (!stack.isEmpty()) {
            ArrayList<Integer> peeks = stack.pop();
            int leftNearLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
            for (Integer peek : peeks) {
                res[peek][0] = leftNearLessIndex;
                res[peek][1] = -1;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{-1, 3, -1, -4, 6, 3, 6, 7};
        int[][] arr1 = getNearLessByViolenceLoop(arr);
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < 2; j++) {
                System.out.print(arr1[i][j]);
            }
        }
        System.out.println();
//        int[][] arr2 = getNearLessNoRepeatByMonotonicStack(arr);
//        for (int i = 0; i < arr.length; i++) {
//            for (int j = 0; j < 2; j++) {
//                System.out.print(arr2[i][j]);
//            }
//        }
//        System.out.println();
        int[][] arr3 = getNearLessByMonotonicStack(arr);
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < 2; j++) {
                System.out.print(arr3[i][j]);
            }
        }
        System.out.println();
    }
}
```
