# [327. 区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

### 解题思路
1. lower =< nums[i-j] = preSum[j] - preSum[i - 1] <= upper
2. preSum[j] - upper <= preSum[i - 1] <= preSum[j] - lower
3. 题目由求nums的子数组中有多少个的和在[lower, upper]中转化为求对于前缀和数组来说（j > i）preSum[j] - preSum[i - 1]的值中有多少在[lower, upper]中，利用归并排序再转化为求对于每一个j有多少个在其左边的i，preSum[j] - upper <= preSum[i - 1] <= preSum[j] - lower

### 代码

```java
// java归并排序递归版
class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        long[] preSum = new long[nums.length];
        getPreSum(nums, preSum);
        return process(preSum, 0, preSum.length - 1, lower, upper);
    }

    // 获取前缀和数组
    // nums[i-j] = preSum[j] - preSum[i - 1]
    // nums[0-j] = preSum[j]
    public void getPreSum(int[] nums, long[] preSum) {
        preSum[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i];
        }
    }

    public int process(long[] preSum, int left, int right, int lower, int upper) {
        // 在遍历中并没有考虑到preSum[i - 1]不存在的情况，也就是nums[0-j]，下面的merge最长只能从nums[j]到nums[1-j]
        if (left == right) {
            return preSum[left] >= lower && preSum[left] <= upper ? 1 : 0;
        }
        int mid = left + ((right - left) >> 1);
        // 左右两区域中各自有多少个满足条件的加上大区域内有多少个，大区域又作为上一级的某一个左右区域被返回
        return process(preSum, left, mid, lower, upper) + process(preSum, mid + 1, right, lower, upper) + merge(preSum, left, mid, right, lower, upper);
    }

    public int merge(long[] arr, int left, int mid, int right, int lower, int upper) {
        int ans = 0;
        int regionLeft = left;
        int regionright = left;
        // 对于当前的左区域，把每个右区域当j，看看其左边的这一块有几个符合条件的i
        // 设置两个左闭右开的区间值，从left开始
        // 由于归并排序导致的左右子区域的有序性进而导致的指针进动不回退性，区间在不断的往右进动，因为j对应的preSum[j]在增大，对应的preSum[i - 1]所成立的范围也在不断增大
        // 区间值碰到mid时是基本条件，arr[regionleft]要保证大于等于min，arr[regionright]要小于等于max，保证[arr[regionleft], arr[regionright]]是[min, max]的子集
        for (int i = mid + 1; i <= right; i++) {
            long min = arr[i] - upper;
            long max = arr[i] - lower;
            while ((regionLeft <= mid) && (arr[regionLeft] < min)) {
                regionLeft++;
            }
            while ((regionright <= mid) && (arr[regionright] <= max)) {
                regionright++;
            }
            ans += (regionright - regionLeft);
        } 

        // 一模一样，类型改成long而已
        long[] helpArr = new long[right - left + 1];
        int leftPoint = left;
        int rightPoint = mid + 1;
        int count = 0;
        while ((leftPoint <= mid) && (rightPoint <= right)) {
            helpArr[count++] = arr[leftPoint] < arr[rightPoint] ? arr[leftPoint++] : arr[rightPoint++];
        }
        while (leftPoint <= mid) {
            helpArr[count++] = arr[leftPoint++];
        }
        while (rightPoint <= right) {
            helpArr[count++] = arr[rightPoint++];
        }
        for (int i = 0; i < helpArr.length; i++) {
            arr[left + i] = helpArr[i];
        }
        return ans;
    }
}
```
